# [一些集合的面试题](https://github.com/13046255574/blog/issues/10)

## 说一下hashmap的特性
- 1、hashmap存储键值对实现快速存取，允许为null。key值 不可重复，key值相同则覆盖值
- 2、非同步，线程不安全
- 3、底层是hash表，不保证有序
---

## hashmap的底层原理
- jdk1.7：数组+链表
- jdk1.8：数组+链表+红黑树
- 基于数组+链表，大量的元素都放在同一个桶的时候，链表就会比较长，这时候hashmap就相当于一个单链表，遍历的复杂度为O(n)，引入了红黑树之后效率为O(logn)
  
##  负载因子为什么是0.75
  - 提供了时间和空间之间的选择；大于0.75，数组里面容纳的元素太挤，容易发生hash碰撞，小于0.75则可能浪费空间
---
## 槽位为什么是2的n次幂
### 为了让哈希后的结果更加均匀
- n-1 & hash
为了让哈希后的结果更加均匀
如果17-1 & hash  &：同为1才为1，其他都为零

- 1111 1101 1101 1111 1010 0000 1111 0000
- 0000 0000 0000 0000 0000 0000 0001 0000
结果：hashcode参加&运算后被更多的0屏蔽，计算结果只剩下0、16，这对于hashmap是一种灾难，计算结果将会**大大趋同**，key没有均匀的分布在node数组上
### 等价于length取模
- 当length总是2的n次方时，length-1 & h运算等价于对length取模，也就是h%length，&比%具有更高的效率
- hash算法本质：高位运算、取模运算
- 最终的目的：hash后的结果更均匀的分布，减少hash碰撞，提升hashmap的运行效率
----

## hashmap的put方法
- 1、计算key的hash值
- 2、如果散列表为空，调用resize进行初始化
- 3、如果没有发生碰撞，直接添加元素到散列表中
- 4、如果发生碰撞（hashcode值相等），进行三种判断
    - key地址相同或者equals后内容相同，替换旧值
    - 如果是红黑树，调用树的插入方法
    - 链表结构，循环遍历链表，尾插法插入
- 5、如果桶满了大于阈值，则resize进行扩容
---

