# [快速理解脏读、不可重复读、幻读和MVCC](https://github.com/liu-cj25/blog/issues/11)

# Mysql

# 快速理解脏读、不可重复读、幻读和MVCC
## 脏读
- 脏读，就是事务A读取了事务B未提交的数据
  
## 不可重复读
- 不可重复读就是事务A，执行的过程很长，当执行了第一次数据读取，此时事务B进行了修改数据，导致事务A再次读取数据的时候，发现数据不对（比如100，B变成了101，A再次读取就是101了，本来是100才对）
- 不可重复读是指前后多次读取，数据内容不一致（update）

## 幻读
- 事务A进行读取数据的时候是100条，此时事务B进行了增加或删除，变成了不是100条，此时事务A再次读取，发现条数不一致，这就是幻读
- 幻读就是前后多次读取，数据总量不一致（增删）

## 不可重复读和幻读到底有什么区别
- 不可重复读是读取了其他事务更改的数据，针对update操作。解决：使用行级锁，锁住这行，事务A多次读取操作完成后蔡释放锁，这个时候才允许其他事务更改刚才的数据
- 幻读是读取了其他事务增加的数据，针对insert和delete操作。解决：使用表级锁，锁住整张表，事务A多次读取数据总量之后才释放锁，这个时候才允许其他事务新增数据。

## 数据库事务四大特性
- 原子性：事务包含的数据库操作要么全部成功，要么全部失败
- 隔离性：一个事物未提交的数据是否对其他事务可见。级别有读未提交、读已提交、可重复读、串行化
- 持久性：数据操作后的改变是永久性的
- 一致性：一个事务执行之前和执行之后都必须处于一致性状态（两个用户的钱加起来不变）

## 隔离级别
|        | 脏读  | 不可重复读 |幻读|
|  ----  | ----  |   ---|---|
| 读未提交  | 会 |会|会|
| 读已提交  | 不会 |会|会
| 可重复读  | 不会 |不会|会
| 串行化  | 不会 |不会|不会
## mysql默认隔离级别
- Mysql的默认隔离级别就是Repeatable read。（可重复读）

## 悲观锁、乐观锁
- 悲观锁，处理数据的整个过程中，都处于锁定状态
- 乐观锁，基于数据版本记录机制实现。为数据增加一个版本标识，增加一个version字段来实现，读取出数据的时候将此版本号一同读出，更新时，对此版本号加1
- 此时，将提交数据的版本数据与数据库表对应记录的版本信息比对，如果提交的数据版本

## MVCC
- 多版本并发控制：读取数据时候通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务session会看到自己特定版本的数据，版本链
- 指的是在读已提交和可重复读这两种隔离级别下的select操作会访问版本链记录的过程
- 这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。select可以去版本链拿记录，这就实现了读-写，写-读的并发操作，提升系统性能。
### 版本链
我们来理解下版本链的概念。InnoDB引擎中，它的聚簇索引记录中有两个必要的隐藏列：
- 1、trx_id
  >  这个id用来存储每次对聚簇索引记录进行修改的时候的事务id
- 2、roll_pointer
  >  每次对聚簇索引进行修改的时候都会把老版本写入undo.log日志中。这个roll_pointer中就是存了一个指针，指向上一个版本的位置，通过他来获取上一个版本的记录信息

| id|name |trx_id|roll_pointer|
|---|---|---|---|
| 1| 小明|50|上一个版本的地址|

比如现在有个事务id是60的执行的这条记录的修改语句
```sql
update table set name='小明1' where id =1
```
这个时候undo就会存在，就是60这条记录指向50
| id|name |trx_id|roll_pointer|
|---|---|---|---|
| 1| 小明|60|上一个版本的地址|
| | |||
| 1| 小明|50|上一个版本的地址|

## ReadView
- 读已提交的隔离级别下，每次查询都会生成一个独立的readview
- 可重复读是第一次读的时候生成一个readview，之后的读都是复用之前的readview